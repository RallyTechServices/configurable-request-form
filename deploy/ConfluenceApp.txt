<!-- for confluence, the head/body tags interfere with rendering -->

    <title>Configurable Request Form</title>
    <!--  (c) 2014,2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Fri Oct 16 2015 11:18:21 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Oct 16 2015 11:18:21 GMT-0600 (MDT)";
    </script>
    
    <script type="text/javascript" src="https://demo-west.rallydev.com//apps/2.0/sdk-debug.js?apiKey=_PUT_APIKEY_HERE_"></script>

<!-- for confluence, don't render as a viewport, so we override the app creation step -->

    <script type="text/javascript">
        Ext.override(Rally.sdk.Bootstrapper,{
            _launchAppInViewport: function (className, settings, timeboxScope) {
                console.log('_launchAppInViewport');
                this._wireIoHeaderHandlers();
                this.app = this._createApp(className, settings, timeboxScope);
    
                Ext.create('Ext.container.Container', {
                    layout: 'fit',
                    items: [ this.app ],
                    renderTo: 'tech_services_target',
                    height: 800,
                    width: 800
                });
            }
        });
        
    </script>
    
    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.AttachmentUploader',{
    extend: 'Rally.ui.detail.AttachmentUploader',

    uploadAttachments: function(formData){
        var url = Rally.ui.detail.AttachmentUploader.legacyAttachmentEndpoint;
        //    file = files[0];
        //
        //var formData = new FormData();
        //formData.append('file', file);

        this.xhr.open('POST', url, true);

        this.xhr.send(formData);
    }
});

Ext.define('Rally.technicalservices.AttachmentEditor',{
    extend: 'Ext.panel.Panel',
    alias: 'widget.tsattachmenteditor',
    height: 200,
    width: '100%',
    record: undefined,

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    initComponent: function(){
        this.callParent(arguments);

        this._store = Ext.create('Ext.data.Store',{
            fields: ['filename','content','description'],
            data: []
        });

        this.add({
            xtype: 'rallygrid',
            columnCfgs: this._getColumnCfgs(),
            showPagingToolbar: false,
            showRowActionsColumn: false,
            store: this._store,
            emptyText: 'No Attachments',
            hideHeaders: true
        });

        this.add({
            xtype: 'filebutton',
            text: 'Upload',
            margin: 10,
            cls: 'secondary rly-small',
            listeners: {
                change: this.addFile,
                scope: this

            }
        });


    },
    addFile: function(e, value, filepath){
        var formData = new FormData();
        formData.append('file', e.fileInputEl.dom.files[0]);

        var filename = e.fileInputEl.dom.files[0].name || filepath.split(/\/|\\/).pop();
        this._store.add({filename: filename, description: '', content: formData});
    },
    removeFile: function(grid, rowIndex, colIndex) {
        var rec = grid.getStore().getAt(rowIndex);
        this._store.remove(rec);
    },
    _getColumnCfgs: function(){
        var me = this;
        return [{
            xtype:'actioncolumn',
            width:40,
            items: [{
                icon: '/slm/js-lib/rui/builds/rui/resources/css/images/trash-icon.png',
                tooltip: 'Remove file',
                scope: me,
                handler: me.removeFile
            }]
        },{
            dataIndex: 'filename',
            text: 'File',
            flex: 1,
            editor: {
                xtype: 'filefield',
                buttonConfig: {
                    cls: 'rly-small secondary'
                }
            },
            renderer: function(v,m,r){
                if (v == null){
                    return 'Click to Add...'
                }
                return v;
            }
        },{
            dataIndex: 'name',
            text: 'Name'
        },{
            dataIndex: 'description',
            text: 'Description'
        }];
    },
    getValue: function(){
        return this._store.data.items;
    }

});

(function () {
    var Ext = window.Ext4 || window.Ext;

    var userSearchComboBox = function(field, record, initToContextUser) {
        var project = Rally.data.util.Record.getProject(record);
        var currentUser = record.get(field.name);
        if (_.isObject(currentUser)) {
            currentUser = currentUser._ref;
        }
        if (initToContextUser && record.phantom && !currentUser) {
            currentUser = Rally.environment.getContext().getUser()._ref;
            record.set(field.name, currentUser);
        }

        return Ext.create('Rally.ui.combobox.UserSearchComboBox', {
            project: project,
            name: field.name,
            value: currentUser,
            bubbleEvents: ['select'],
            triggerWrapCls: 'fullwidth',
            plugins: [
                {
                    xclass: 'Rally.ui.detail.plugins.LoadingMonitor'
                }
            ]
        });
    };

    var buildNumberField = function(field, record) {
        var value = Number(record.get(field.name)) || 0;
        return Ext.create('Rally.ui.NumberField', {
            name: field.name,
            displayName: field.displayName,
            value: value,
            labelAlign: 'right',
            height: getDefaultHeight(),
            field: field,
            hideTrigger: true,
            clientMetrics: {
                event: 'blur',
                description: 'field blur'
            }
        });
    };

    var buildPercentDoneBy = function(percentDoneTemplateName, field, record) {
        var tpl = Ext.create(percentDoneTemplateName);
        return Ext.create('Ext.Component', {
            data: record.data,
            tpl: tpl,
            maskOnDisable: false,
            cls: 'percent-done',
            listeners: {
                afterrender: function() {
                    var el = this.getEl();
                    el.on('click', function() {
                        Ext.create('Rally.ui.popover.PercentDonePopover', {
                            target: el,
                            percentDoneData: Ext.applyIf({
                                Notes: "",                                      // Empty string so that NOTES section will not display
                                Release: record.get('Release') || {},           // Avoid fetching release
                                PortfolioItemTypeOrdinal: record.self.ordinal   // Ditto
                            }, record.data),
                            percentDoneName: field.name
                        });
                    });
                }
            }
        });
    };

    var buildDisplayColorField = function (field, record) {
        return Ext.create('Rally.ui.detail.view.DisplayColorField', {
            field: field,
            record: record,
            editable: Rally.ui.detail.DetailHelper.isDetailPageFieldEditable(field, record)
        });
    };

    var buildStateField = function (field, record) {
        return Ext.create('Rally.ui.detail.view.StateField', {
            field: field,
            record: record
        });
    };

    var buildTargetProjectEditor = function(field, record) {
        var project = record.get(field.name);
        if (record.phantom && project === "") {
            project = Rally.environment.getContext().getProject();
        }
        return Ext.create('Rally.ui.detail.view.TargetProjectField', {
            name: field.name,
            milestoneRecord: record,
            value: Rally.util.Ref.getRelativeUri(project),
            editable: Rally.ui.MilestoneTargetProjectPermissionsHelper.canEdit(record)
        });
    };

    var defaultAllowNoEntry = function(field, record) {
        return !field.required || !record.get(field.name);
    };

    function constrainedComboBox(field, record, config) {
        return Ext.widget(Ext.apply({
            xtype: 'rallyfieldvaluecombobox',
            name: field.name,
            value: record.get(field.name),
            field: field,
            labelAlign: 'right',
            labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
            labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
            width: '75%',
            minWidth: 200,
            editable: false,
            allowNoEntry: defaultAllowNoEntry(field, record),
            useNullForNoEntryValue: true,
            plugins: [
                {
                    xclass: 'Rally.ui.detail.plugins.LoadingMonitor'
                }
            ]
        }, config));
    }

    function milestoneField(field, record, readOnly) {
        return Ext.create('Rally.ui.detail.view.MilestonesField', {
            field: field,
            record: record,
            readOnly: readOnly
        });
    }
    function getDefaultHeight(){
        return 25;
    }

    /**
     * @private
     */
    Ext.define('Rally.technicalservices.DetailEditorFactory', {
        requires: [
            'Rally.data.util.Record',
            'Rally.data.wsapi.Filter',
            'Rally.ui.combobox.FieldValueComboBox',
            'Rally.ui.detail.DetailHelper',
            'Rally.ui.detail.view.DetailWebLinkField',
            'Rally.ui.detail.view.DetailNumberField',
            'Rally.ui.detail.view.StateField',
            'Rally.ui.detail.view.DetailReadOnlyRefreshingField',
            'Rally.ui.detail.view.ReadyButton',
            'Rally.ui.renderer.template.progressbar.PercentDoneByStoryCountTemplate',
            'Rally.ui.renderer.template.progressbar.PercentDoneByStoryPlanEstimateTemplate',
            'Rally.ui.popover.PercentDonePopover',
            'Rally.ui.detail.view.MilestonesField',
            'Rally.util.Ref',
            'Rally.ui.combobox.ProjectComboBox'
        ],

        singleton: true,

        labelWidth: 150,
        labelCls: 'tslabel',
        controlWidth: '90%',
        padding: 0,

        getEditor: function (field, record, item_id, margin, field_label) {
            var editor;
            if (this.fieldEditors[field.name]) {
                editor = this.fieldEditors[field.name](field, record);
            } else if (field.attributeDefinition && this.typeEditors[field.attributeDefinition.AttributeType.toLowerCase()]) {
                editor = this.getEditorByType(field, record);
            } else {
                editor = this.defaultRenderer(field, record);
            }

            editor.addCls('detailFieldEditor');
            editor.itemId = item_id;
            editor.fieldLabel = field_label;
            editor.margin = margin;
            editor.labelAlign = 'right';

            return editor;
        },

        getEditorByType: function (field, record) {
            return this.typeEditors[field.attributeDefinition.AttributeType.toLowerCase()](field, record);
        },

        defaultRenderer: function (field, record) {
            return this.typeEditors['string'](field, record);
        },

        fieldEditors: {

            Attachments: function(field, record){

                return Ext.create('Rally.technicalservices.AttachmentEditor',{
                    record: record,
                    title: field.displayName
                });
            },

            Iteration: function (field, record) {
                var currentIteration = record.get(field.name);
                return Ext.create('Rally.ui.combobox.IterationComboBox', {
                    name: field.name,
                    value: currentIteration,
                    allowNoEntry: defaultAllowNoEntry(field, record),
                    showArrows: false,
                    defaultSelectionToFirst: true,
                    defaultToCurrentTimebox: false,
                    labelAlign: 'right',
                    storeConfig: {
                        remoteFilter: true,
                        filters: [
                            buildTimeboxFilter(currentIteration)
                        ],
                        context: {
                            project: Rally.data.util.Record.getProject(record),
                            projectScopeUp: false,
                            projectScopeDown: false
                        }
                    },
                    plugins: [
                        {
                            xclass: 'Rally.ui.detail.plugins.LoadingMonitor'
                        }
                    ]
                });
            },

            Milestones: function(field, record) {
                var readOnly = !Rally.ui.detail.DetailHelper.isDetailPageFieldEditable(field, record);
                return milestoneField(field, record, readOnly);
            },

            Owner: function(field, record) {
                return userSearchComboBox(field, record, record.isUserStory());
            },

            Release: function (field, record) {
                var currentRelease = record.get(field.name);
                return Ext.create('Rally.ui.combobox.ReleaseComboBox', {
                    name: field.name,
                    value: currentRelease,
                    allowNoEntry: defaultAllowNoEntry(field, record),
                    showArrows: false,
                    defaultSelectionPosition: 'first',
                    defaultToCurrentTimebox: false,
                    labelAlign: 'right',
                    storeConfig: {
                        remoteFilter: true,
                        filters: [
                            buildTimeboxFilter(currentRelease)
                        ],
                        context: {
                            project: Rally.data.util.Record.getProject(record),
                            projectScopeUp: false,
                            projectScopeDown: false
                        }
                    },
                    plugins: [
                        {
                            xclass: 'Rally.ui.detail.plugins.LoadingMonitor'
                        }
                    ]
                });
            },
        },

        typeEditors: {

            'boolean': function (field, record) {
                var choices = Ext.create('Ext.data.Store', {
                    fields: ['value', 'display'],
                    data: [
                        {value: true, display: 'Yes'},
                        {value: false, display: 'No'}
                    ]
                });

                return Ext.create('Rally.ui.combobox.ComboBox', {
                    name: field.displayName,
                    store: choices,
                    queryMode: 'local',
                    displayField: 'display',
                    valueField: 'value',
                    width: '25%',
                    minWidth: 200,
                    labelAlign: 'right',
                    labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                    labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                    value: record.get(field.name),
                    defaultSelectionPosition: 'last'
                });
            },
            date: function (field, record) {

                return Ext.create('Rally.ui.DateField', {
                    format: Rally.util.DateTime.getUserExtDateFormat(),
                    validateOnChange: false,
                    name: field.displayName,
                    value: record.get(field.name),
                    width: '25%',
                    minWidth: 200,
                    labelAlign: 'right',
                    labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                    labelCls: Rally.technicalservices.DetailEditorFactory.labelCls
                });
            },
            'decimal': function (field, record) {
                var value = Number(record.get(field.name)) || 0;
                return Ext.create('Rally.ui.NumberField', {
                    name: field.displayName,
                    displayName: field.displayName,
                    value: value,
                    labelAlign: 'right',
                    height: getDefaultHeight(),
                    field: field,
                    hideTrigger: true,
                    width: '25%',
                    labelSeparator: "",
                    minWidth: 200,
                    labelAlign: 'right',
                    labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                    labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                    padding: Rally.technicalservices.DetailEditorFactory.padding
                });
            },
            'integer': function (field, record) {

                var value = Number(record.get(field.name)) || 0;
                return Ext.create('Rally.ui.NumberField', {
                    name: field.displayName,
                    displayName: field.displayName,
                    value: value,
                    labelAlign: 'right',
                    height: getDefaultHeight(),
                    field: field,
                    hideTrigger: true,
                    width: '25%',
                    labelSeparator: "",
                    minWidth: 200,
                    labelAlign: 'right',
                    labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                    labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                    padding: Rally.technicalservices.DetailEditorFactory.padding
                });

            },
            'object': function (field, record) {
                if (field.attributeDefinition.Constrained) {
                    return Ext.create('Rally.ui.combobox.ComboBox', {
                        name: field.displayName,
                        value: record.get(field.name),
                        editable: false,
                        labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                        labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                        labelAlign: 'right',
                        storeConfig: {
                            autoLoad: true,
                            model: field.attributeDefinition.SchemaType,
                            initialValue: record.get(field.name) ? record.get(field.name)._refObjectName : ''
                        },
                        allowNoEntry: defaultAllowNoEntry(field, record)
                    });

                } else {
                    return Ext.create('Rally.ui.TextField', {
                        name: field.displayName,
                        value: record.get(field.name),
                        labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                        labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                        padding: Rally.technicalservices.DetailEditorFactory.padding,
                        labelAlign: 'right'

                    });
                }
            },
            quantity: function (field, record) {
                var value = Number(record.get(field.name)) || 0;
                return Ext.create('Rally.ui.NumberField', {
                    name: field.displayName,
                    displayName: field.displayName,
                    value: value,
                    labelAlign: 'right',
                    height: getDefaultHeight(),
                    field: field,
                    width: '25%',
                    labelSeparator: "",
                    minWidth: 200,
                    labelAlign: 'right',
                    labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                    labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                    padding: Rally.technicalservices.DetailEditorFactory.padding
                });
            },
            rating: function (field, record) {
                if (field.attributeDefinition.Constrained) {
                    return constrainedComboBox(field, record, {
                        allowNoEntry: !field.required || record.get(field.name) === 'None',
                        ratingNoEntryString: '-- No Entry --',
                        noEntryValue: 'None',
                        labelAlign: 'right',
                        useNullForNoEntryValue: false
                    });
                } else {
                    return Ext.create('Rally.ui.TextField', {
                        name: field.displayName,
                        value: record.get(field.name),
                        width: '25%',
                        minWidth: 200,
                        labelAlign: 'right',
                        labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                        labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                        padding: Rally.technicalservices.DetailEditorFactory.padding
                    });
                }
            },
            string: function (field, record) {
                if (field.attributeDefinition.Constrained) {
                    return constrainedComboBox(field, record);
                } else {
                    return Ext.create('Rally.ui.TextField', {
                        name: field.name,
                        value: record.get(field.name),
                        height: getDefaultHeight(),
                        minWidth: 200,
                        labelSeparator: "",
                        labelWidth: Rally.technicalservices.DetailEditorFactory.labelWidth,
                        labelCls: Rally.technicalservices.DetailEditorFactory.labelCls,
                        width: Rally.technicalservices.DetailEditorFactory.controlWidth,
                        padding: Rally.technicalservices.DetailEditorFactory.padding
                    });
                }
            },
            text: function (field, record) {
                var isEditable = Rally.ui.detail.DetailHelper.isDetailPageFieldEditable(field, record),
                    editor;

                if (isEditable) {
                    editor = Ext.create('Rally.technicalservices.RichTextEditor',{
                        field: field,
                        record: record,
                        labelAlign: 'right',
                        padding: Rally.technicalservices.DetailEditorFactory.padding
                    });
                } else {
                    editor = Ext.create('Rally.ui.richtext.RichTextEditorReadOnly', {
                        html: record.get(field.name)
                    });
                }

                if (Rally.ui.detail.DetailHelper.getController()) {
                    Rally.ui.detail.DetailHelper.getController().on('recordupdate', function(record) {
                        editor.setValue(record.get(field.name));
                    });
                }

                return editor;
            },
            web_link: function (field, record) {
                return Ext.create('Rally.ui.detail.view.DetailWebLinkField', {
                    field: field,
                    record: record
                });
            }
        }
    });

})();
Ext.define('Rally.technicalservices.RichTextEditor', {
    extend: 'Ext.Container',
    layout: {type: 'hbox'},
    width: Rally.technicalservices.DetailEditorFactory.controlWidth,
    alias: 'widget.tsrichtexteditor',
    height: 200,

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },

    initComponent: function(){
        this.callParent(arguments);

        var record = this.record,
            field = this.field;

        this.add({
            xtype: 'container',
            html: Ext.String.format('<div class="tslabel">{0}</div>',field.name),
            width: Rally.technicalservices.DetailEditorFactory.labelWidth,
            padding: 5
        });
        var editor = Ext.create('Rally.ui.richtext.RichTextEditor', {
                field: field,
                record: record,
                title: field.name,
                itemId: 'rt-editor',
                margin: 5,
                name: field.name,
                value: record.get(field.name),
                growToFitContent: true,
                allowImageUpload: true,
                renderTpl: '<div class="richTextToolbar"></div><div class="richTextContent"></div>',
                EDITOR_MIN_HEIGHT: 110,
                toolbarAlwaysEnabled: false,
                showUndoButton: true,
                disableUndoButtonWithToolbar: false,
                indicatorFoldUnder: true,
                useLinkBubble: true,
                flex: 1,
                listeners: {
                    focus: function () {
                        var focusedField = Ext.ComponentQuery.query('rallydetailfieldcontaineredpcomplete[focused=true]')[0];

                        if (focusedField) {
                            var editor = focusedField.editor;
                            if (editor !== this) {
                                focusedField.clearSelection();
                                editor.hasFocus = false;
                                editor.fireEvent('blur');
                                if (editor.collapse) {
                                    editor.collapse();
                                }
                            }
                        }
                    },
                    blur: function () {
                        var fields = Ext.ComponentQuery.query('rallydetailfieldcontaineredpcomplete');
                        var previouslyFocusedField = _.find(fields, function (field) {
                            if (field.editor) {
                                return field.editor.hasFocus;
                            }
                        }, this);
                        if (previouslyFocusedField) {
                            previouslyFocusedField.focusField();
                        }
                    },
                    imageuploaded: function(imageInfo) {
                        var controller = Rally.ui.detail.DetailHelper.getController();
                        if(controller) {
                            controller._handleImageUpload(imageInfo);
                        }
                    }
                }
            });

        editor.on('boxready', this._resize, this);
        if (Rally.ui.detail.DetailHelper.getController()) {
            Rally.ui.detail.DetailHelper.getController().on('recordupdate', function(record) {
                editor.setValue(record.get(field.name));
            });
        }
        this.add(editor);
    },
    _resize: function(){
        this.down('#rt-editor').setHeight(this.height);
    },
    getValue: function(){
        return this.down('#rt-editor').getValue();
    },
    validator: function(value){
        return true;
    },
    validate: function(){
        var validation = this.validator(this.down('#rt-editor').getValue());
        if (validation === true){
            return true;
        }
        Ext.create('Rally.ui.tooltip.ToolTip', {
            target : this.down('#rt-editor').getEl(),
            html: '<div class="tsinvalid">' + validation + '</div>',
            autoShow: true,
            destroyAfterHide: true
        });
        return false;
    }
});

Ext.define('Rally.technicalservices.plugin.CellEditing', {
        extend: 'Ext.grid.plugin.CellEditing',
        alias: 'plugin.tscellediting',

        clicksToEdit: 1,

        //=============================
        // Private method override danger zone
        //
        onEnterKey: Ext.emptyFn,

        onEscKey: function() {
            this.callParent(arguments);

            //Need to return true to prevent underlying key map
            //from stopping the escape key event in case other components need to handle it
            return true;
        },

        //
        // End private method override danger zone
        //=============================

        /**
         * @event recordupdatesuccess
         * Publishes the global {@link Rally.Message#recordUpdateSuccess} message when a record
         * is successfully updated via inline-editing
         * @param {Object[]} records The updated records
         */
        /**
         * @event recordupdatefailure
         * Publishes the global {@link Rally.Message#recordUpdateFailure} message when a record
         * is unsuccessfully updated via inline-editing
         */

        init: function() {
            this.callParent(arguments);

            this.grid.addEvents(
                /**
                 * @event
                 * Fires after an inline edit occurs
                 * @param {Rally.ui.grid.Grid} this
                 * @param {Ext.grid.plugin.Editing} editor The editor object from Ext.grid.plugin.CellEditing#edit
                 * @param {Object} event The e object from Ext.grid.plugin.CellEditing#edit
                 */
                'inlineedit',
                /**
                 * @event
                 * Fires when an inline edit has been saved
                 * @param {Rally.ui.grid.Grid} this
                 * @param {Rally.data.Model[]} records The records array from Ext.data.Operation#callback
                 * @param {Ext.data.Operation} operation See Ext.data.Operation#callback
                 * @param {Rally.data.Model} record The original record that was updated
                 * @param {Ext.grid.column.Column) The column that was updated
                     */
                'inlineeditsaved'
            );

            this.mon(this.grid, 'edit', this._saveInlineEdit, this);
             this.mon(this, 'beforeedit', this._onBeforeEdit, this);
        },

        getEditor: function(record, column) {
            console.log('getEditor',record);
            var editor = this.callParent(arguments);
            editor.completeOnEnter = false;
            editor.record = record;

            if (!editor._beforeCompleteListenerAdded) {
                editor.on('beforecomplete', this._onBeforeStart, this);
                editor._beforeCompleteListenerAdded = true;
            }
            editor.offsets = [0, 1];
            return editor;
        },

        showEditor: function(ed, context, value) {
            var superclassShowEditorFn;

            if (Ext.isFunction(ed.prepareEditor)) {
                superclassShowEditorFn = Ext.bind(this.superclass.showEditor, this, [ed, context, value]);
                ed.prepareEditor(context, superclassShowEditorFn);
            } else {
                this._resetFieldIfNeeded(ed.field, context.record, context.field);
                this.callParent(arguments);
            }
        },

        _resetFieldIfNeeded: function (editorField, record, columnFieldName) {
            if (!editorField || !editorField.setField || !record || !record.getField || !columnFieldName) {
                return;
            }

            var newField = record.getUnmappedField ? record.getUnmappedField(columnFieldName) : null;

            if (!newField) {
                newField = record.getField(columnFieldName);
            }

            if (newField) {
                editorField.setField(newField);
            }
        },

        onSpecialKey: function(editor, field, e) {
            var keyCode = e.getKey(),
                sm;

            if (keyCode === e.ENTER && !editor.completeOnEnter) {
                this.recordAction({ component: this.grid, description: 'typed enter on grid cell' });
                e.stopEvent();

                sm = this.grid.getSelectionModel();
                sm.onEditorEnter(this, field, e);
            } else if (keyCode === e.TAB) {
                this.recordAction({ component: this.grid, description: 'typed tab on grid cell' });
            }

            this.callParent(arguments);
        },

        onCellClick: function(view, cell, colIdx, record, row, rowIdx, e) {
            if (this._eventTargetIsNotALink(e)) {
                this.recordAction({ component: this.grid, description: 'clicked grid cell' });
                this.callParent(arguments);
            }
        },

        _eventTargetIsNotALink: function(e) {
            return Ext.isEmpty(e.getTarget()) ||
                Ext.isEmpty(e.getTarget().dom) ||
                e.getTarget().dom.nodeName.toLowerCase() !== 'a';
        },

        _onRecordRemoved: function(store, record){
            var activeEditor = this.getActiveEditor();
            if (activeEditor){
                // If the active editor is tied to the record that was removed from the store
                // then then cancel the edit to remove the editor
                if(activeEditor.record === record){
                    activeEditor.cancelEdit();
                } else {
                    //When a record is removed, we need to reposition
                    //the activeEditor to the new rows position
                    activeEditor.realign(true);
                    if(activeEditor.field.doAlign) {
                        activeEditor.field.doAlign();
                    }
                }
            }
        },

        _onBeforeEdit: function(editor, e) {
            var field;
            if (e.record.getField) {
                field = e.record.getField(e.field);
                return !!(field && !field.readOnly && !field.hidden && e.record.get('updatable'));
            }
        },

        _saveInlineEdit: function(editor, event) {
            var changes = event.record.getChanges();
            if (!Ext.Object.isEmpty(changes)) {
                var grid = this.grid,
                    record = this.context.record,
                    column = this.context.column;

                grid.suspendLayouts();

                grid.fireEvent('inlineedit', this, editor, event);
                event.record.save({
                    requester: grid,
                    callback: function(savedRecord, operation) {
                        var success = operation.success,
                            grid = this.grid;

                        if (this.publishMessages) {
                            if (success) {
                                var associatedRecords;
                                if (grid.store.isCollectionStore) {
                                    associatedRecords = grid.store.record;
                                }
                                this.publish(Rally.Message.objectUpdate, savedRecord, _.keys(changes), this, [associatedRecords]);
                                this.publish(Rally.Message.recordUpdateSuccess, savedRecord);
                            } else {
                                this.publish(Rally.Message.recordUpdateFailure);
                            }
                        }

                        grid.fireEvent('inlineeditsaved', this, savedRecord, operation, record, column);
                        if (success && Ext.getClassName(grid) === 'Rally.ui.grid.Grid') {
                            grid.highlightRowForRecord(savedRecord);
                        }

                        grid.resumeLayouts();
                    },
                    scope: this,
                    params: {
                        fetch: grid.getAllFetchFields()
                    }
                });
            }
        },

        _onBeforeStart: function(editor) {
            var retval = !(editor.field && editor.field.store && editor.field.store.loading);

            if (!retval) {
                editor.hideEdit();
            }
            return retval;
        },

        getActiveEditorInputId: function() {
            return this.getActiveEditor().field.inputEl.id;
        }
    });


Ext.define('Rally.technicalservices.FieldConfigurationGrid', {

    extend: 'Ext.grid.Panel',

    alias: 'widget.tsfieldconfig',

    uses: [
        'Ext.grid.plugin.CellEditing',
        'Ext.grid.property.Store',
        'Ext.grid.property.HeaderContainer',
        'Ext.XTemplate',
        'Ext.grid.CellEditor',
        'Ext.form.field.Date',
        'Ext.form.field.Text',
        'Ext.form.field.Number',
        'Ext.form.field.ComboBox'
    ],

    /**
     * @cfg {String} valueField
     * The name of the field from the property store to use as the value field name.
     * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
     */
    valueField: 'value',

    /**
     * @cfg {String} nameField
     * The name of the field from the property store to use as the property field name.
     * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
     */
    nameField: 'name',

    /**
     * @cfg {Boolean} inferTypes
     * True to automatically infer the {@link #sourceConfig type} based on the initial value passed
     * for each field. This ensures the editor remains the correct type even if the value is blanked
     * and becomes empty.
     */
    inferTypes: true,

    /**
     * @cfg {Number/String} [nameColumnWidth=115]
     * Specify the width for the name column. The value column will take any remaining space.
     */

    // private config overrides
    enableColumnMove: false,
    columnLines: true,
    stripeRows: false,
    trackMouseOver: false,
    clicksToEdit: 1,
    enableHdMenu: false,

    gridCls: Ext.baseCSSPrefix + 'property-grid',

    // private
    initComponent : function() {
        var me = this;

        me.source = me.source || {};
        me.addCls(me.gridCls);
        me.plugins = me.plugins || [];

        // Enable cell editing. Inject a custom startEdit which always edits column 1 regardless of which column was clicked.
        me.plugins.push(new Ext.grid.plugin.CellEditing({
            clicksToEdit: me.clicksToEdit,

            // Inject a startEdit which always edits the value column
            startEdit: function(record, column) {
                // Maintainer: Do not change this 'this' to 'me'! It is the CellEditing object's own scope.
                return this.self.prototype.startEdit.call(this, record, me.valueColumn);
            }
        }));

        me.selModel = {
            selType: 'cellmodel',
            onCellSelect: function(position) {
                // We are only allowed to select the value column.
                position.columnHeader = me.valueColumn;
                position.column = me.valueColumn.getVisibleIndex();
                return this.self.prototype.onCellSelect.call(this, position);
            }
        };

        me.sourceConfig = Ext.apply({}, me.sourceConfig);

        // Create a property.Store from the source object unless configured with a store
        if (!me.store) {
            me.propStore = me.store = new Ext.grid.property.Store(me, me.source);
        }
        me.configure(me.sourceConfig);

        if (me.sortableColumns) {
            me.store.sort('name', 'ASC');
        }
        me.columns = new Ext.grid.property.HeaderContainer(me, me.store);

        me.addEvents(
            /**
             * @event beforepropertychange
             * Fires before a property value changes.  Handlers can return false to cancel the property change
             * (this will internally call {@link Ext.data.Model#reject} on the property's record).
             * @param {Object} source The source data object for the grid (corresponds to the same object passed in
             * as the {@link #source} config property).
             * @param {String} recordId The record's id in the data store
             * @param {Object} value The current edited property value
             * @param {Object} oldValue The original property value prior to editing
             */
            'beforepropertychange',
            /**
             * @event propertychange
             * Fires after a property value has changed.
             * @param {Object} source The source data object for the grid (corresponds to the same object passed in
             * as the {@link #source} config property).
             * @param {String} recordId The record's id in the data store
             * @param {Object} value The current edited property value
             * @param {Object} oldValue The original property value prior to editing
             */
            'propertychange'
        );
        me.callParent();

        // Inject a custom implementation of walkCells which only goes up or down
        me.getView().walkCells = this.walkCells;

        // Set up our default editor set for the 4 atomic data types
        me.editors = {
            'date'    : new Ext.grid.CellEditor({ field: new Ext.form.field.Date({selectOnFocus: true})}),
            'string'  : new Ext.grid.CellEditor({ field: new Ext.form.field.Text({selectOnFocus: true})}),
            'number'  : new Ext.grid.CellEditor({ field: new Ext.form.field.Number({selectOnFocus: true})}),
            'boolean' : new Ext.grid.CellEditor({ field: new Ext.form.field.ComboBox({
                editable: false,
                store: [[ true, me.headerCt.trueText ], [false, me.headerCt.falseText ]]
            })})
        };

        // Track changes to the data so we can fire our events.
        me.store.on('update', me.onUpdate, me);
    },

    configure: function(config){
        var me = this,
            store = me.store,
            i = 0,
            len = me.store.getCount(),
            nameField = me.nameField,
            valueField = me.valueField,
            name, value, rec, type;

        me.configureLegacy(config);

        if (me.inferTypes) {
            for (; i < len; ++i) {
                rec = store.getAt(i);
                name = rec.get(nameField);
                if (!me.getConfig(name, 'type')) {
                    value = rec.get(valueField);
                    if (Ext.isDate(value)) {
                        type = 'date';
                    } else if (Ext.isNumber(value)) {
                        type = 'number';
                    } else if (Ext.isBoolean(value)) {
                        type = 'boolean';
                    } else {
                        type = 'string';
                    }
                    me.setConfig(name, 'type', type);
                }
            }
        }
    },

    getConfig: function(fieldName, key, defaultValue) {
        var config = this.sourceConfig[fieldName],
            out;

        if (config) {
            out = config[key];
        }
        return out || defaultValue;
    },

    setConfig: function(fieldName, key, value) {
        var sourceCfg = this.sourceConfig,
            o = sourceCfg[fieldName];

        if (!o) {
            o = sourceCfg[fieldName] = {
                __copied: true
            };
        } else if (!o.__copied) {
            o = Ext.apply({
                __copied: true
            }, o);
            sourceCfg[fieldName] = o;
        }
        o[key] = value;
        return value;
    },

    // to be deprecated in 4.2
    configureLegacy: function(config){
        var me = this;

        me.copyLegacyObject(config, me.customRenderers, 'renderer');
        me.copyLegacyObject(config, me.customEditors, 'editor');
        me.copyLegacyObject(config, me.propertyNames, 'displayName');

        //<debug>
        // exclude types since it's new
        if (me.customRenderers || me.customEditors || me.propertyNames) {
            if (Ext.global.console && Ext.global.console.warn) {
                Ext.global.console.warn(this.$className, 'customRenderers, customEditors & propertyNames have been consolidated into a new config, see "sourceConfig". These configurations will be deprecated.');
            }
        }
        //</debug>
    },

    copyLegacyObject: function(config, o, keyName){
        var key;

        for (key in o) {
            if (o.hasOwnProperty(key)) {
                if (!config[key]) {
                    config[key] = {};
                }
                config[key][keyName] = o[key];
            }
        }
    },

    // @private
    onUpdate : function(store, record, operation) {
        var me = this,
            v, oldValue;

        if (me.rendered && operation == Ext.data.Model.EDIT) {
            v = record.get(me.valueField);
            oldValue = record.modified.value;
            if (me.fireEvent('beforepropertychange', me.source, record.getId(), v, oldValue) !== false) {
                if (me.source) {
                    me.source[record.getId()] = v;
                }
                record.commit();
                me.fireEvent('propertychange', me.source, record.getId(), v, oldValue);
            } else {
                record.reject();
            }
        }
    },

    // Custom implementation of walkCells which only goes up and down.
    // Runs in the scope of the TableView
    walkCells: function(pos, direction, e, preventWrap, verifierFn, scope) {
        var me = this,
            valueColumn = me.ownerCt.valueColumn;

        if (direction == 'left') {
            direction = 'up';
        } else if (direction == 'right') {
            direction = 'down';
        }
        pos = Ext.view.Table.prototype.walkCells.call(me, pos, direction, e, preventWrap, verifierFn, scope);

        // We are only allowed to navigate to the value column.
        pos.columnHeader = valueColumn;
        pos.column = valueColumn.getVisibleIndex();
        return pos;
    },

    // @private
    // Returns the correct editor type for the property type, or a custom one keyed by the property name
    getCellEditor : function(record, column) {
        var me = this,
            propName = record.get(me.nameField),
            val = record.get(me.valueField),
            editor = me.getConfig(propName, 'editor'),
            type = me.getConfig(propName, 'type'),
            editors = me.editors;

        // A custom editor was found. If not already wrapped with a CellEditor, wrap it, and stash it back
        // If it's not even a Field, just a config object, instantiate it before wrapping it.
        if (editor) {
            if (!(editor instanceof Ext.grid.CellEditor)) {
                if (!(editor instanceof Ext.form.field.Base)) {
                    editor = Ext.ComponentManager.create(editor, 'textfield');
                }
                editor = me.setConfig(propName, 'editor', new Ext.grid.CellEditor({ field: editor }));
            }
        } else if (type) {
            switch (type) {
                case 'date':
                    editor = editors.date;
                    break;
                case 'number':
                    editor = editors.number;
                    break;
                case 'boolean':
                    editor = me.editors['boolean'];
                    break;
                default:
                    editor = editors.string;
            }
        } else if (Ext.isDate(val)) {
            editor = editors.date;
        } else if (Ext.isNumber(val)) {
            editor = editors.number;
        } else if (Ext.isBoolean(val)) {
            editor = editors['boolean'];
        } else {
            editor = editors.string;
        }

        // Give the editor a unique ID because the CellEditing plugin caches them
        editor.editorId = propName;
        return editor;
    },

    beforeDestroy: function() {
        var me = this;
        me.callParent();
        me.destroyEditors(me.editors);
        me.destroyEditors(me.customEditors);
        delete me.source;
    },

    destroyEditors: function (editors) {
        for (var ed in editors) {
            if (editors.hasOwnProperty(ed)) {
                Ext.destroy(editors[ed]);
            }
        }
    },

    /**
     * Sets the source data object containing the property data.  The data object can contain one or more name/value
     * pairs representing all of the properties of an object to display in the grid, and this data will automatically
     * be loaded into the grid's {@link #store}.  The values should be supplied in the proper data type if needed,
     * otherwise string type will be assumed.  If the grid already contains data, this method will replace any
     * existing data.  See also the {@link #source} config value.  Example usage:
     *
     *     grid.setSource({
     *         "(name)": "My Object",
     *         "Created": Ext.Date.parse('10/15/2006', 'm/d/Y'),  // date type
     *         "Available": false,  // boolean type
     *         "Version": .01,      // decimal type
     *         "Description": "A test object"
     *     });
     *
     * @param {Object} source The data object.
     * @param {Object} [sourceConfig] A new {@link #sourceConfig object}. If this argument is not passed
     * the current configuration will be re-used. To reset the config, pass `null` or an empty object literal.
     */
    setSource: function(source, sourceConfig) {
        var me = this;

        me.source = source;
        if (sourceConfig !== undefined) {
            me.sourceConfig = Ext.apply({}, sourceConfig);
            me.configure(me.sourceConfig);
        }
        me.propStore.setSource(source);
    },

    /**
     * Gets the source data object containing the property data.  See {@link #setSource} for details regarding the
     * format of the data object.
     * @return {Object} The data object.
     */
    getSource: function() {
        return this.propStore.getSource();
    },

    /**
     * Sets the value of a property.
     * @param {String} prop The name of the property to set.
     * @param {Object} value The value to test.
     * @param {Boolean} [create=false] `true` to create the property if it doesn't already exist.
     */
    setProperty: function(prop, value, create) {
        this.propStore.setValue(prop, value, create);
    },

    /**
     * Removes a property from the grid.
     * @param {String} prop The name of the property to remove.
     */
    removeProperty: function(prop) {
        this.propStore.remove(prop);
    }

    /**
     * @cfg {Object} store
     * @private
     */
    /**
     * @cfg {Object} columns
     * @private
     */
});

Ext.define('Rally.technicalservices.BooleanFieldComboBox',{
    extend: 'Rally.ui.combobox.FieldComboBox',
    alias: 'widget.tsbooleanfieldcombobox',

    _isNotHidden: function(field) {
        return (!field.hidden && field.attributeDefinition && field.attributeDefinition.AttributeType == 'BOOLEAN');
    }
});

Ext.define('Rally.technicalservices.settings.FormConfiguration',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.tsformconfigsettings',
    config: {
        value: undefined,
        fields: undefined,
        decodedValue: {}
    },
    notAllowedFields: ['ScheduleState','Tags','PredecessorsAndSuccessors','Predecessors','Successors','Project','Milestones','Workspace','Changesets','Parent','PortfolioItem','DisplayColor'],
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',

    width: '100%',
    cls: 'column-settings',

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },

    onRender: function() {
        var decodedValue = {};
        if (this.value && !_.isEmpty(this.value)){
            decodedValue = Ext.JSON.decode(this.value);
        }
        this.callParent(arguments);

        var data = [];

        _.each(this.fields, function(f){
            if (this._isFieldAllowed(f)){
                var dsp = false,
                    def_value = f.defaultValue || '',
                    req = f.required || false,
                    order = null;

                if (decodedValue[f.name]){
                    dsp = true;
                    def_value = decodedValue[f.name].defaultValue;
                    req = decodedValue[f.name].required;
                    order = order;
                }
                data.push({fieldName: f.name, displayName: f.displayName, display: dsp, defaultValue: def_value, required: req, fieldObj: f})
            }
        }, this);

        data = _.sortBy(data, 'order');
        this._store = Ext.create('Ext.data.Store', {
            fields: ['fieldName', 'displayName','display', 'defaultValue', 'required','order'],
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
            showPagingToolbar: false,
            showRowActionsColumn: false,
            store: this._store,
            height: 400,
            editingConfig: {
                publishMessages: false
            },
            viewConfig: {
                plugins: {
                    ptype: 'gridviewdragdrop',
                    dragText: 'Drag and drop to reorder'
                }
            }
        });
    },
    _isFieldAllowed: function(field){
        var forbiddenTypes = ['WEB_LINK'];

        if (Ext.Array.contains(this.notAllowedFields, field.name)){
            return false;
        }

        if (field.readOnly === true || field.hidden === true){
            return false;
        }

        if (field && !field.attributeDefinition){
            return false;
        }

        //Not showing Weblinks for now
        if (Ext.Array.contains(forbiddenTypes, field.attributeDefinition.AttributeType)){
            return false;
        }

        return true;
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [
            {
                text: 'Field',
                dataIndex: 'displayName',
                flex: 1
            },
            {
                text: 'Show',
                dataIndex: 'display',
                renderer: function (value) {
                    return value === true ? 'Yes' : 'No';
                },
                editor: {
                    xtype: 'rallycombobox',
                    displayField: 'name',
                    valueField: 'value',
                    editable: false,
                    storeType: 'Ext.data.Store',
                    storeConfig: {
                        remoteFilter: false,
                        fields: ['name', 'value'],
                        data: [
                            {'name': 'Yes', 'value': true},
                            {'name': 'No', 'value': false}
                        ]
                    }
                }
            },
            {
                text: 'Required',
                dataIndex: 'required',
                renderer: function (value) {
                    return value === true ? 'Yes' : 'No';
                },
                editor: {
                    xtype: 'rallycombobox',
                    displayField: 'name',
                    valueField: 'value',
                    editable: false,
                    storeType: 'Ext.data.Store',
                    storeConfig: {
                        remoteFilter: false,
                        fields: ['name', 'value'],
                        data: [
                            {'name': 'Yes', 'value': true},
                            {'name': 'No', 'value': false}
                        ]
                    }
                }
            },{
                xtype: 'actioncolumn',
                iconCls: 'icon-delete',
                scope: this,
                items: [{
                    scope: this,
                    handler: function(grid, row, col, x ,y ) {
                        console.log('edit',grid, row, col, x, y);
                    }
                }]
            },
            {
                text: 'Default Value',
                dataIndex: 'defaultValue',
                emptyCellText: '',
                flex: 3,
                editRenderer: function(m,v,r){
                    return Rally.technicalservices.DetailEditorFactory.getEditor(r.get('fieldObj'));
                }
            }
        ];
        return columns;
    },
    _editRenderer: function(v,m,r){
        console.log('editRenderer',v,m,r);
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {},
            order = 1;
        this._store.each(function(record) {
            if (record.get('display')) {
                mappings[record.get('fieldName')] = {
                    required: record.get('required'),
                    defaultValue: record.get('defaultValue'),
                    order: order++
                };
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        if (_.isEmpty(this._buildSettingValue())) {
           errors.push('At least one field must be shown.');
        }
        return errors;
    },
    validate : function() {
        var me = this,
            isValid = me.isValid();
        if (isValid !== me.wasValid) {
            me.wasValid = isValid;
            me.fireEvent('validitychange', me, isValid);
        }
        if (!isValid){
            var html = this.getErrors().join('<br/>');
            Ext.create('Rally.ui.tooltip.ToolTip', {
                target : this.getEl(),
                html: '<div class="tsinvalid">' + html + '</div>',
                autoShow: true,
                anchor: 'bottom',
                destroyAfterHide: true
            });

        }

        return isValid;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});

Ext.define('Rally.technicalservices.RequestForm', {
    extend: 'Ext.panel.Panel',
    alias: 'widget.tsrequestform',
    logger: new Rally.technicalservices.Logger(),

    layout: {
        type: 'vbox',       // Arrange child items vertically
        //type: 'table',
        //columns: 1,
        //padding: 10,
        //tableAttrs: {"class": "tstbl"},
        //trAttrs: {"class": "tstbl"}
    },

    config: {
        title: '',
        instructions: 'These are instructions for filling out this form',
        model: undefined,
        formConfiguration: undefined,
        thankYouMessage: "Thank you for your submission."
    },

    /**
     * Properties that are populated during the creation of this object
     */
    newRecord: null,

    constructor: function(config){
        this.mergeConfig(config);
        this.logger.log('constructor', config, this.config);
        this.callParent(arguments);
    },
    initComponent: function () {
        this.callParent();
        this.addEvents('save','ready','onwarning','onerror');
        this._build(this.model);
    },

    _build: function (model) {
        this.logger.log('_build', model);
        this.newRecord = this._getNewRecord(model);

        this._addInstructions(this.instructions);

        this._addFields(this.newRecord);

    },
    _addInstructions: function(){
        var title = this.add(Ext.create('Ext.container.Container',{
            tpl: '<tpl><div class="tsinstructions">{instructions}</div></tpl>'
        }));
        title.update(this);
    },

    _addFields: function(newRecord){
        var model = this.model;
        this.logger.log('_addFields', this.formConfiguration);
        if (!_.isEmpty(this.formConfiguration)){
            _.each(this.formConfiguration, function(field_obj, field_name){
                var model_field = model.getField(field_name);
                if (model_field){
                    var item_id = field_name,
                        margin = 10,
                        field_label = model_field.displayName;

                    var item = Rally.technicalservices.DetailEditorFactory.getEditor(model_field,newRecord,item_id, margin, field_label);
                    item.labelCls = "tslabel";
                    if (field_obj.required){
                        item.validator = function(value) {
                            if (Ext.isEmpty(value) || value == null || value == ''){
                                return Ext.String.format('{0} is required.', field_name);
                            }
                            return true;
                        }
                    }
                    item.msgTarget = 'side';
                    item.on('boxready', this._resize, this);
                    this.add(item);
                }
            }, this);
            this.doLayout();
            this.fireEvent('ready', this);
        } else {
            var msg = "No fields were loaded to display.  Please check the configuration settings to verify that fields are configured for this App."
            this.add({
                xtype: 'container',
                html: msg
            });
        }
    },
    _resize: function(cmp){
        this.logger.log('_resize');
        this.doLayout();
    },
    _getNewRecord: function(model){
        var newFields = {};
        Ext.each(this.formConfiguration, function(field_obj, field_name){
            this.logger.log(field_name, field_obj);
            if (field_obj.defaultValue){
                newFields[field_name].setValue(field_obj.defaultValue);
            }
        },this);
        this.logger.log('_getNewRecord', newFields);
        var rec = Ext.create(model, newFields);
        return rec;
    },

    _updateNewRecord: function(){
        var exceptionFields = ["Attachments"],
            valid = true;
        _.each(this.formConfiguration, function(field_obj, field_name){
            if (!Ext.Array.contains(exceptionFields, field_name)) {
                this.logger.log('_updateNewRecord', field_name, this.down('#' + field_name));

                var val = this.down('#' + field_name).getValue() || field_obj.defaultValue || null;
                valid = this.down('#' + field_name).validate();
                if (!valid) {
                    return false;
                }
                this.newRecord.set(field_name, val);

            }
        }, this);
        return valid;
    },
    save: function () {
        if (!this._updateNewRecord()){
            return false;
        };
        var attachments = null;
        if (this.down('#Attachments')){
            attachments = this.down('#Attachments').getValue() || null;
        }

        this.newRecord.save({
            scope: this,
            callback: function(result, operation) {
                if(operation.wasSuccessful()) {
                    if (attachments) {
                        this._updateAttachments(result, 'Attachments', attachments).then({
                            scope: this,
                            success: function(){
                                this.fireEvent('save', result);
                            },
                            failure: function(msg){
                                this.fireEvent('save', result);
                                this.fireEvent('onerror', {message: msg});
                            }
                        });
                    } else {
                        this.fireEvent('save',result);
                    }
                } else {
                    var msg = Ext.String.format("Submission could not be saved: {0}", operation.error.errors[0]);
                    this.fireEvent('onerror', {message: msg});
                }
            }
        });
    },
    _uploadAttachment: function(record, val){
        var deferred = Ext.create('Deft.Deferred');

        var uploader = Ext.create('Rally.technicalservices.AttachmentUploader',{
            record: record,
            listeners: {
                scope: this,
                uploadprogress: function(percent){
                    this.logger.log('upload %', percent);
                },
                uploaded: function(u){
                    this.logger.log('attachment uploaded', u);
                },
                attached: function(attachmentRecord){
                    this.logger.log('attachment attached', attachmentRecord);
                    deferred.resolve();
                },
                failure: function(z){
                    this.logger.log('failure',z);
                    deferred.reject('Upload Failed');
                }
            }
        });
        uploader.uploadAttachments(val);
        return deferred;
    },
    _updateAttachments: function(record, field_name, val){
        this.logger.log('_updateAttachments', record, field_name, val);
        var deferred = Ext.create('Deft.Deferred');
        var me = this;

        var promises = [];
       _.each(val, function(v){
            var fn = function(){
                me._uploadAttachment(record, v.get('content'));
            }
            promises.push(fn);
        });

        Deft.Chain.sequence(promises).then({
            success: function(){
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    }
});

Ext.define('Rally.technicalservices.WsapiToolbox',{
    singleton: true,

    fetchModel: function(model_name){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.wsapi.ModelFactory.getModel({
            type: model_name,
            success: function(model) {
                deferred.resolve(model);
            },
            failure: function(){
                deferred.reject('Error loading model: ' + model_name);
            }
        });
        return deferred.promise;
    }
});

Ext.define("configurable-request-form", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    config: {
        defaultSettings: {
            formFieldConfiguration: {},
            formInstructions: ''
        }
    },
    formModel: undefined,
    formModelName: 'HierarchicalRequirement',
    items: [],
    externalAppSettingsKey: 'technicalServicesConfigurableFormAppSettings',
    launch: function() {
        if (this.isExternal()){
            this.getExternalAppSettings(this.externalAppSettingsKey);
        } else {
            this.onSettingsUpdate(this.getSettings());
        }
    },
    _prepareApp: function(){
        this.logger.log('_prepareApp', this.formModelName, this.formInstructions, this.formFieldConfiguration);
        Rally.technicalservices.WsapiToolbox.fetchModel(this.formModelName).then({
            scope: this,
            success: function(model){
                this.formModel = model;
                this._validateSettings(model);
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: msg});
            }
        });
    },
    _validateSettings: function(model){
        this.logger.log('_validateSettings');
        var config_obj = this.formFieldConfiguration;
        if (!Ext.isObject(config_obj)){
            config_obj = Ext.JSON.decode(this.formFieldConfiguration);
        }

        this.logger.log('_validateSettings formFieldConfig', config_obj);
        if (_.isEmpty(config_obj)){
            this.add({
                xtype: 'container',
                itemId: 'display_box',
                flex: 1,
                html: 'No form configuration has been defined.<br/>Please use the App Settings to configure the form.',
                style: {
                    fontFamily: 'ProximaNovaLight, Helvetica, Arial'
                }
            });
        } else {
            this.formConfiguration = config_obj;
            this.model = model;
            this._showGrid(model);
        }
    },
    _buildForm: function(model, form_config){
        this.logger.log('_buildForm');

        this._clearWindow();

        this.add({xtype:'container',itemId:'display_box', flex: 1});
        this.add({xtype:'container',itemId:'button_box', flex: 1, layout: {type: 'hbox', pack: 'center'}});

        this.down('#display_box').add({
            xtype: 'tsrequestform',
            itemId: 'requestform',
            model: model,
            instructions: this.formInstructions,
            formConfiguration: form_config,
            listeners: {
                scope: this,
                save: this._onSaved,
                onwarning: this._onWarning,
                onerror: this._onError,
                ready: this._onReady
            }
        });
        this.down('#button_box').add({
            xtype:'rallybutton',
            text: 'Submit',
            itemId: 'btn-submit',
            style: {
                textAlign: 'center'
            },
            width: 75,
            scope: this,
            handler: this._save
        });
        this.down('#button_box').add({
            xtype:'rallybutton',
            text: 'Cancel',
            itemId: 'btn-cancel',
            style: {
                textAlign: 'center'
            },
            width: 75,
            scope: this,
            handler: this._cancel
        });

    },
    _save: function(){
        var requestForm = this.down('#requestform');
        requestForm.save();
    },
    _onSaved: function(newRecord){
        this.logger.log('_onSaved',newRecord);
        Rally.ui.notify.Notifier.showCreate({artifact: newRecord});
        this._showGrid(this.model);
    },
    _cancel: function(){
        this._showGrid(this.model);
    },
    _onWarning: function(obj){
        Rally.ui.notify.Notifier.showWarning(obj);
    },
    _onError: function(obj){
        Rally.ui.notify.Notifier.showError(obj);
    },
    _onReady: function(form){
        this.logger.log('_onReady', form);

        form.doLayout();
        form.setWidth('95%')
        this.down('#display_box').doLayout();
    },

    _clearWindow: function(){
        if (this.down('#story-grid')){
            this.down('#story-grid').destroy();
        }
        if (this.down('#display_box')){
            this.down('#display_box').destroy();
        }
        if (this.down('#button_box')){
            this.down('#button_box').destroy();
        }
    },
    _showGrid: function(model) {
        this._clearWindow();

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: [model],
            autoLoad: true,
            enableHierarchy: true,
            sorters: [
                {
                    property: 'CreationDate',
                    direction: 'DESC'
                }
            ]
        }).then({
            scope: this,
            success: function(store){
                var modelNames = [model],
                    context = this.getContext();
                var gb = this.add({
                    xtype: 'rallygridboard',
                    context: context,
                    itemId: 'story-grid',
                    modelNames: modelNames,
                    toggleState: 'grid',
                    stateful: false,
                    plugins: [{
                            ptype: 'rallygridboardfieldpicker',
                            headerPosition: 'right',
                            modelNames: modelNames,
                            stateful: true,
                            stateId: context.getScopedStateId('columns-example')
                        }
                    ],
                    gridConfig: {
                        store: store,
                        columnCfgs: ['Name','ScheduleState']
                    },
                    height: this.getHeight()
                });
                var btn = gb.getHeader().getLeft().add({
                    xtype: 'rallybutton',
                    text: 'New Request',
                    margin: 5
                });
                btn.on({
                    click: this._onNewRequest,
                    scope: this
                });
            },
            scope: this
        });
    },

    _onNewRequest: function() {
        this.logger.log('_onNewRequest');
        this._buildForm(this.model, this.formConfiguration)
    },

    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    getSettingsFields: function() {
        var formModel = this.formModel;
        var fields = [];
        if (formModel){
            fields = formModel.getFields();
        }

        return [{
            name: 'formInstructions',
            xtype: 'textareafield',
            fieldLabel: 'Form Instructions',
            labelAlign: 'top',
            autoShow: true,
            width: '100%',
            margin: 15,
            height: 100
        },{
                name: 'formFieldConfiguration',
                xtype: 'tsformconfigsettings',
                fieldLabel: 'Form Field Configuration - Drag rows to specify order on the form',
                margin: 15,
                labelAlign: 'top',
                fields: fields
            }];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);
        this.saveExternalAppSettings(this.externalAppSettingsKey, settings);
        this._prepareApp();
    },
    saveExternalAppSettings: function(key, settings){

        var prefs = {};
        _.each(settings, function(val, setting_key){
            var pref_key = key + '.' + setting_key;
            prefs[pref_key] = val;
        });

        this.logger.log('SaveExternalAppSettings', key, settings, prefs);
        Rally.data.PreferenceManager.update({
            project: this.getContext().getProject()._ref,
            settings: prefs,
            scope: this,
            success: function(updatedRecords, notUpdatedRecords) {
                this.logger.log('settings saved', key, updatedRecords, notUpdatedRecords);
            }
        });
    },
    getExternalAppSettings: function(key){
        Rally.data.PreferenceManager.load({
            project: this.getContext().getProject()._ref,
            additionalFilters: [{
                property: 'name',
                operator: 'contains',
                value: key
            }],
            scope: this,
            cache: false,
            success: function(prefs) {
                this.logger.log('settings loaded', key, prefs);
                _.each(prefs, function(val, pref_name){
                    if (/\.formInstructions$/.test(pref_name)){
                        this.formInstructions = val;
                    }
                    if (/\.formFieldConfiguration$/.test(pref_name)){
                        if (val && !_.isEmpty(val)){
                            this.formFieldConfiguration = Ext.JSON.decode(val);
                        }
                    }
                }, this);

                this._prepareApp();
            }
        });
    }
});

            
               Rally.launchApp('configurable-request-form', {
                   name: 'Configurable Request Form'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.tslabel {
    font-family: ProximaNovaSemiBold,Helvetica,Arial;
    color: #222;
    font-size: 12px;
    text-align: right;
    float: right;
    padding: 10;
}

.tsinvalid {
    color: #c30;
    font-weight: bold;
    font-family: ProximaNovaSemiBold,Helvetica,Arial;
}

.tsinstructions {
    font-family: ProximaNovaSemiBold,Helvetica,Arial;
    color: #222;
    font-size: 14px;
    padding: 10px;
}

.tstbl {
    padding: 5px;
}

.tstbl tr:nth-child(odd){
    background-color: #e6e6e6;
}
.tstbl tr:nth-child(even){
    background-color: #ffffff;
}
    </style>

<div id="tech_services_target"></div>